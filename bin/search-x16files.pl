#!/usr/bin/env perlml

use v5.12;
use warnings;

package bin::merge;

use File::Find;
use FindBin qw/$Bin/;
use JSON::PP;
use YAML qw/Dump DumpFile/;
use Search::Indexer;
use String::CRC32;
use CGI::Tiny;
use Template;
use Util::H2O::More qw/d2o ddd/;
binmode STDOUT, ":encoding(UTF-8)";

require Data::Dumper;

my $full_idx = new Search::Indexer(dir => "$Bin/../hub/full_idx", writeMode => 1);
my $file     = "$Bin/search-x16files.json"; # generated by hub/bin/merge
my $json     = eval { local $/; do { open my $fh, "<", $file || die "Failed to open $file\n"; <$fh> } } or undef; 
my $lookup   = eval { decode_json $json } or undef;

my $tt = Template->new({
  INCLUDE_PATH => "$Bin/../hub/templates",
});

sub do_search {
  my ($query, $max) = @_;
  # search
  my $result      = $full_idx->search($query);
  my $scores      = $result->{scores};
  my $n_docs      = keys %$scores;

  $max = ($n_docs < $max) ? $n_docs : $max;
  my @best_docs   = (sort {$scores->{$b} <=> $scores->{$a}} keys %$scores)[0 .. $max];

  # build results
  my $message .= ($n_docs > 0) ? "$n_docs documents found, displaying $max\n" : "";

  my @results;
  foreach my $docId (@best_docs) {
    next if not $docId;
    push @results, $lookup->{$docId};
  }
  return $message, \@results;
}

cgi {
  my $cgi = $_;
  my $query = $cgi->query_param('q');
  my $html;
  my ($message, $results) = do_search($query,100);
  $tt->process("search-results.tt", { query => $query, message => $message, results => $results }, \$html); 

  $cgi->render( html => $html );

  return;
};
