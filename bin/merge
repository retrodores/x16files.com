#!/usr/bin/env perlml

use v5.12;
use warnings;

package bin::merge;

use File::Find;
use FindBin qw/$Bin/;
use JSON::PP;
use YAML qw/Dump DumpFile/;
use Search::Indexer;
use String::CRC32;
use Util::H2O::More qw/d2o ddd o2d Getopt2h2o/;
use Tie::IxHash;
binmode STDOUT, ":encoding(UTF-8)";

my $opts_ref = Getopt2h2o \@ARGV, { verbose => undef }, qw/verbose|v/;

my $jsonpp = JSON::PP->new->ascii->pretty->allow_nonref;

my ($categories,$authors,$appnames);
my ($full_idx_lookup, $author_idx_lookup, $appname_idx_lookup);

# Idx set up...

my $full_idx_dir = "$Bin/../full_idx";
my $author_idx_dir = "$Bin/../author_idx";
my $appname_idx_dir = "$Bin/../appname_idx";

my @idx_files = glob("$full_idx_dir/ix* $author_idx_dir/ix* $appname_idx_dir/ix*");
unlink @idx_files if @idx_files;

my $full_idx    = Search::Indexer->new(dir => $full_idx_dir, writeMode => 1);
my $author_idx  = Search::Indexer->new(dir => $author_idx_dir, writeMode => 1);
my $appname_idx = Search::Indexer->new(dir => $appname_idx_dir, writeMode => 1);

# main driver based on JSON files present in the "files" directory

find(\&process, ("$Bin/../files") ) if not caller;

my $cats = {
  games           => { category => "Games",         slug => "games",       description => "Games and other entertaintment" },
  editors         => { category => "Editors",       slug => "editors",     description => "Text and code editors for Commander X16" },
  "file and disk" => { category => "File and Disk", slug => "files",       description => "File and disk utilities" },
  graphics        => { category => "Graphics",      slug => "graphics",    description => "Sprite, video, and image editors for Commander X16" },
  internet        => { category => "Internet",      slug => "internet",    description => "Network and serial utilities for Commander X16" },
  programming     => { category => "Programming",   slug => "programming", description => "Programming tools and libraries for on and off the X16" },
  sound           => { category => "Sound",         slug => "sound",       description => "Audio and music utilities for Commander X16" },
  systems         => { category => "System",        slug => "system",      description => "Firmware and system utilities for Commander X16" },
  tools           => { category => "Tools",         slug => "tools",       description => "Miscellaneous tools and utilities for Commander X16" },
};

# dump YAML files
foreach my $category (keys %{$categories}) {
  my $CAT_INDEX = { category => $cats->{lc $category}->{category}, description => $cats->{lc $category}->{description}, packages => $categories->{lc $category} };
  my $CAT_YAML = Dump($CAT_INDEX);
  my $filename = sprintf "%s.yaml", $cats->{lc $category}->{slug};
  open my $fh, ">:encoding(UTF-8)", "$Bin/../data/$filename";
  print $fh <<EOF;
# This YAML file is automatically generated and is provided for reference only.
# Do NOT deploy, distribute, or integrate it without prior authorization.
# https://x16files.com

$CAT_YAML
EOF
  say "wrote $filename" if $opts_ref->verbose;
  close $fh;
}

my $AUTHOR_INDEX = { category => "Authors", description => "Listing of X16 programs by author", authors => $authors };
DumpFile("$Bin/../data/authors.yaml", $AUTHOR_INDEX);
say "wrote authors.yaml" if $opts_ref->verbose;

my $ranked = [];
foreach my $author (sort { @{$authors->{$b}} <=> @{$authors->{$a}} } keys %$authors) {
  push @$ranked, { name => $author, score => scalar @{$authors->{$author}} };
}

my $RANKED_AUTHOR_INDEX = { category => "Authors", description => "Listing of X16 programs by author", authors => $ranked };
DumpFile("$Bin/../data/leaderboard.yaml", $RANKED_AUTHOR_INDEX);
say "wrote leaderboard.yaml" if $opts_ref->verbose;

sub process {
  my $file = $File::Find::name; 
  my @path = split /\//, $file;
  return undef if $path[-1] !~ m/json$/;

  local $@; # error detection 

  # open file and dump contents to $json
  my $json = eval { local $/; do { open my $fh, "<", $file || die "Failed to open $file\n"; <$fh> } } or undef; 

  if ($@) { # file read error
    say STDERR $@;
    return;
  }

  my $info = eval { $jsonpp->decode($json) } or undef;

  if ($@) { # json decode error
    say STDERR $@;
    return;
  }

  my $category = lc $info->{category};
  my $author   = $info->{author}->{name};
  my $appname  = $info->{name};

  # hash for building index pages
  push @{$categories->{$category}}, $info; 
  push @{$authors->{$author}}, $info;
  push @{$appnames->{$appname}}, $info;
  
  # look ups for search based on CRC32 docId
  my $docId = crc32($json);
  $full_idx_lookup->{$docId} = $info;

  # build different indexes (they all use the same $docId

  ## full entry text 
  $full_idx->add($docId, $json);

  ## main author
  $author_idx->add($docId, $author);
 
  ## application name
  $appname_idx->add($docId, $appname);
}

open my $fh, ">", "$Bin/../../cgi-bin/search-x16files.json";
print $fh $jsonpp->encode($full_idx_lookup);
close $fh;

1

# TO DO, update POD
__END__

